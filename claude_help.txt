# Negotiation System Redesign - Architecture & Implementation Guide

## Problem Analysis

### Issues in Current Implementation

#### 1. **Intent Classification Confusion** (email_intent_classifier.py)

```
Current Issue:
┌─────────────────────────────────────────────────────────────┐
│  "Can you do $1500?"                                        │
│                                                             │
│  Could be classified as:                                    │
│  • negotiation (price discussion)                           │
│  • information_seeking (asking for rate)                    │
│  • price_inquiry (asking our rate)                          │
│                                                             │
│  Result: Inconsistent classification → Wrong response       │
└─────────────────────────────────────────────────────────────┘
```

**Root Cause**: Overlapping intent categories without context awareness.

#### 2. **Round Counting Problem** (negotiation.py + NegotiationAction)

```
Current Issue:
┌─────────────────────────────────────────────────────────────┐
│  Message 1 (Broker): "What equipment do you have?"          │
│  Message 2 (Carrier): "53' dry van"                         │
│  Message 3 (Broker): "What's your rate?"                    │
│  Message 4 (Carrier): "$1800"                               │
│  Message 5 (Broker): "Can you do $1500?"                    │
│                                                             │
│  Current round count: 3 (counts ALL carrier messages)       │
│  Actual negotiation rounds: 1 (only one price exchange)     │
│                                                             │
│  Result: System thinks we're in round 3, rejects early!     │
└─────────────────────────────────────────────────────────────┘
```

**Root Cause**: `ChatHistoryAnalyzer` counts ALL carrier messages as rounds.

#### 3. **Mixed Concerns in execute_negotiation**

```python
# Current problematic flow in NegotiationAction.execute_negotiation():

async def execute_negotiation(self, data):
    # 1. Get intent
    intent = email_intent.classify(...)
    
    # 2. If negotiation intent AND low confidence...
    if intent == NEGOTIATION and confidence < 80:
        # 3. Process broker response (info gathering)
        info_check = await self.process_broker_response(...)
        
        # 4. PROBLEM: This path still calls negotiation.offer_negotiation()
        #    which increments rounds even though this was info exchange!
        ai_res = negotiation.offer_negotiation(...)  # ← ROUND INCREMENTED!
```

---

## Proposed Architecture

### State Machine Approach

```
┌──────────────────────────────────────────────────────────────────────────┐
│                       CONVERSATION STATE MACHINE                          │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────┐    Info       ┌───────────────┐    Has Min    ┌─────────┐ │
│   │ INITIAL │───Provided───▶│ INFO_GATHERING │───Info───────▶│  READY  │ │
│   └─────────┘               └───────────────┘               └─────────┘ │
│        │                           │                             │       │
│        │                           │ Price                       │       │
│        │                           │ Mentioned                   │       │
│        │                           ▼                             │       │
│        │                    ┌─────────────┐◀────────────────────┘       │
│        └───Price Offered───▶│ NEGOTIATING │                             │
│                             └─────────────┘                             │
│                               /    │    \                                │
│                              /     │     \                               │
│                             ▼      ▼      ▼                              │
│                      ┌────────┐ ┌────────┐ ┌─────────┐                   │
│                      │ACCEPTED│ │REJECTED│ │ STALLED │                   │
│                      └────────┘ └────────┘ └─────────┘                   │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Separate Round Counters

```
┌──────────────────────────────────────────────────────────────────────────┐
│                        CONVERSATION CONTEXT                               │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   info_exchanges: int        │  Counts: Info questions/answers           │
│   ─────────────────────────  │  • "What equipment?"                       │
│                              │  • "We run dry vans"                       │
│                              │  • "What's the pickup date?"               │
│                              │  Does NOT affect negotiation strategy      │
│                                                                          │
│   negotiation_rounds: int    │  Counts: Price discussions only           │
│   ─────────────────────────  │  • "We can do $1400"                       │
│                              │  • "I need $1800"                          │
│                              │  • "How about $1600?"                      │
│                              │  THIS determines accept/reject timing     │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Simplified Intent Categories

```
OLD (Overlapping):                    NEW (Non-Overlapping):
┌────────────────────────┐            ┌────────────────────────┐
│ • negotiation          │            │ PRICE-RELATED:         │
│ • information_seeking  │            │ • PRICE_OFFER          │
│ • bid_acceptance       │  ────▶     │ • PRICE_INQUIRY        │
│ • bid_rejection        │            │ • PRICE_ACCEPTANCE     │
│ • rate_confirmation    │            │ • PRICE_REJECTION      │
│ • broker_setup         │            │                        │
│ • load_details         │            │ INFO-RELATED:          │
│ • availability_check   │            │ • LOAD_DETAILS         │
│ • booking_request      │            │ • INFO_REQUEST         │
│ • unclear              │            │ • INFO_RESPONSE        │
└────────────────────────┘            │                        │
                                      │ ADMIN:                 │
                                      │ • RATE_CONFIRMATION    │
                                      │ • BOOKING_REQUEST      │
                                      │                        │
                                      │ FALLBACK:              │
                                      │ • UNCLEAR              │
                                      └────────────────────────┘
```

---

## Implementation Comparison

### Current Flow (Problematic)

```python
# In NegotiationAction.execute_negotiation():

1. Classify intent (context-blind)
     ↓
2. If NEGOTIATION intent:
     ↓
3. Check confidence score
     ↓
4. If low: process_broker_response() + offer_negotiation()
   If high: offer_negotiation() directly
     ↓
5. offer_negotiation() counts ALL messages as rounds
     ↓
6. Round 3+ → May reject even if negotiation just started!
```

### New Flow (Fixed)

```python
# In NegotiationOrchestrator.process_message():

1. Build ConversationContext from history
   - Separately count info_exchanges vs negotiation_rounds
     ↓
2. Classify intent WITH context awareness
   - Same message can mean different things at different stages
     ↓
3. Update state machine
   - INFO_REQUEST/INFO_RESPONSE → increment info_exchanges
   - PRICE_OFFER/PRICE_INQUIRY → increment negotiation_rounds
     ↓
4. Generate response based on TRUE negotiation round
     ↓
5. Round 3 now means 3 ACTUAL price exchanges, not 3 messages!
```

---

## Key Code Changes

### 1. Context-Aware Classification

```python
# OLD: Same classification regardless of conversation state
def classify(self, email_content):
    # Just pattern matching, no context
    if "sounds good" in email_content:
        return "bid_acceptance"

# NEW: Different interpretation based on state
def classify(self, message, context):
    if context.state == ConversationState.NEGOTIATING:
        # "ok" after price proposal = acceptance
        if self._is_short_affirmative(message) and context.last_carrier_price:
            return MessageIntent.PRICE_ACCEPTANCE
    else:
        # "ok" during info gathering = acknowledgment
        return MessageIntent.INFO_RESPONSE
```

### 2. Separate Round Tracking

```python
# OLD: Single counter for all exchanges
class ChatHistoryAnalyzer:
    def analyze(self):
        carrier_msgs = [l for l in lines if l.startswith('Me')]
        negotiation_round = len(carrier_msgs) + 1  # ALL messages!

# NEW: Separate counters
class ConversationStateMachine:
    def transition(self, context, intent, classification):
        if intent in [MessageIntent.PRICE_OFFER, MessageIntent.PRICE_INQUIRY]:
            context.negotiation_rounds += 1  # Only price discussions
        elif intent in [MessageIntent.INFO_REQUEST, MessageIntent.INFO_RESPONSE]:
            context.info_exchanges += 1  # Info doesn't affect negotiation
```

### 3. Strategy Based on TRUE Rounds

```python
# OLD: Rejects based on total message count
def should_reject(broker_offer, min_price, round_num, below_min_count):
    if round_num >= 6:  # Could be 5 info + 1 price exchange!
        return True

# NEW: Rejects based on actual negotiation rounds
def calculate_response(context, min_price, max_price, sweet_spot):
    round_num = context.negotiation_rounds  # Only price rounds!
    
    # NEVER accept in first 2 NEGOTIATION rounds
    if round_num <= 2:
        return {'action': 'counter', 'price': calculated_counter}
    
    # Round 3+ of PRICE discussion → can accept above floor
    if round_num >= 3 and broker_offer >= min_price:
        return {'action': 'accept'}
```

---

## Integration Guide

### Step 1: Replace the Classifier

```python
# In NegotiationAction, replace:
from services.email_intent_classifier import IntentClassifierService

# With:
from negotiation_redesign import ContextAwareClassifier, ConversationHistoryParser
```

### Step 2: Update execute_negotiation

```python
async def execute_negotiation(self, data: dict):
    # ... existing setup code ...
    
    # NEW: Use orchestrator instead of scattered logic
    from negotiation_redesign import NegotiationOrchestrator
    
    orchestrator = NegotiationOrchestrator()
    
    result = orchestrator.process_message(
        broker_message=latest,
        negotiation_history=currBid.get("negotiations", []),
        load_offer=curr_offer,
        pricing={
            "min_price": float(currBid.get("minRate", 0)),
            "max_price": float(currBid.get("maxRate", 0)),
            "sweet_spot": float(currBid.get("minRate", 0)) * 1.1
        },
        carrier_info=carrier
    )
    
    # Handle result
    if result['action'] == 'accept':
        await supertruck.update_bid(tenant_id, currBid["id"], 
            {"isAcceptedByBroker": True, "status": "accepted"})
    
    await supertruck.negotiate(tenant_id, {
        "rate": result.get('proposed_price'),
        "negotiationDirection": "outgoing",
        "bidId": currBid["id"],
        "negotiationRawEmail": result['response']
    })
```

### Step 3: Update NegotiationService

```python
# Replace the entire offer_negotiation method with:
def offer_negotiation(self, broker_message, min_price, max_price, 
                      chat_history, load_details) -> Dict:
    
    from negotiation_redesign import NegotiationOrchestrator
    
    orchestrator = NegotiationOrchestrator()
    
    result = orchestrator.process_message(
        broker_message=broker_message,
        negotiation_history=chat_history,
        load_offer=load_details,
        pricing={
            "min_price": min_price,
            "max_price": max_price,
            "sweet_spot": min_price + (max_price - min_price) * 0.6
        }
    )
    
    return {
        'response': result['response'],
        'proposed_price': f"{result['proposed_price']:.2f}" if result.get('proposed_price') else None,
        'status': self._map_action_to_status(result['action'])
    }

def _map_action_to_status(self, action):
    mapping = {
        'accept': 'accepted',
        'reject': 'rejected',
        'counter': 'negotiating',
        'info_request': 'negotiating',
        'info_response': 'negotiating',
        'clarify': 'negotiating'
    }
    return mapping.get(action, 'negotiating')
```

---

## Testing Scenarios

### Scenario 1: Info Exchange Before Negotiation

```
Broker: "Do you have a 53' van available?"
Carrier: "Yes, what's the load details?"
Broker: "Dallas to Houston, 40k lbs, Monday pickup"
Carrier: "What's the rate?"
Broker: "Can do $1400"
Carrier: "Need $1800"  ← FIRST negotiation round
Broker: "$1500?"
Carrier: "Best is $1700" ← SECOND negotiation round

OLD: Round 4 (counts all carrier messages) → Might reject!
NEW: Round 2 (only price exchanges) → Still negotiating
```

### Scenario 2: Mixed Info and Price Discussion

```
Broker: "$1400 for Dallas to Houston"
Carrier: "$1800" ← Round 1
Broker: "What's your MC number?"  ← INFO, not round
Carrier: "MC-123456"  ← INFO response
Broker: "$1500?"
Carrier: "$1700" ← Round 2

OLD: Round 3 → Might accept too low
NEW: Round 2 → Correctly continues negotiating
```

---

## Summary of Changes

| Component | Current Issue | Fix |
|-----------|--------------|-----|
| Intent Classifier | Context-blind, overlapping categories | Context-aware with state machine |
| Round Counter | Counts all messages | Separate info vs negotiation counters |
| NegotiationAction | Mixed info/negotiation logic | Clean orchestrator pattern |
| Accept/Reject Logic | Based on total messages | Based on actual price rounds |
| State Management | Implicit, scattered | Explicit state machine |

---

## Files to Modify

1. **negotiation_redesign.py** (new) - Core orchestrator
2. **services/negotiation.py** - Simplify to use orchestrator
3. **actions/negotiation.py** - Update execute_negotiation
4. **services/email_intent_classifier.py** - Can be deprecated or simplified

## Migration Path

1. Add `negotiation_redesign.py` to services/
2. Update `NegotiationAction.execute_negotiation()` to use orchestrator
3. Test with existing conversation histories
4. Gradually deprecate old `IntentClassifierService`